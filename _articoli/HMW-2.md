---
layout: page
title: "Homework 2"
permalink: /articoli/HMW-2/
---

**Author:** {{ site.author }}  
**Matricola:** {{ site.author_student_number }}  
**Email:** [{{ site.author_email }}](mailto:{{ site.author_email }})  
**Course:** {{ site.course }} — {{ site.university }}  
**Academic Year:** {{ site.academic_year }}

---

# Dataset and Distribution

## Dataset

A **dataset** is a structured collection of related data, usually organized as a table. In this tabular form:

- **Rows** represent individual observations or statistical units (for example: a student, an object, or an event).
- **Columns** represent variables or attributes measured for each observation (for example: Age, Gender, Grade).

Variables are commonly classified as:
- **Quantitative** — numeric measures (integers or continuous values like height or weight).
- **Qualitative (categorical)** — named categories without intrinsic order (for example: gender, type).
- **Ordinal** — categorical variables with a natural order but not appropriate for arithmetic operations (for example: education level or rating).
- **Temporal** — date or time values.

Datasets can be described as:
- **Structured** — with a fixed schema (relational tables, CSV files).
- **Semi‑structured** — having some organization but a flexible schema (JSON, XML).
- **Unstructured** — lacking a predefined schema (texts, images, audio).

In a DBMS (for example MySQL, SQLite, Microsoft Access) datasets are stored as tables that can be queried, filtered, and analyzed. A dataset is a finite realization of a population or process and is the basis for descriptive and inferential analysis.

---

## Distribution

A **distribution** describes how the values of a variable, or of several variables jointly, are spread across their possible values. Distributions can be considered in two main ways:

- **Empirical (frequency) distributions**: obtained from the dataset by counting occurrences or computing relative frequencies (for example, frequency tables, histograms).
- **Probabilistic (theoretical) distributions**: mathematical models that assign probabilities to possible outcomes (for example: Normal, Binomial, Poisson).

By dimensionality, distributions include:
- **Univariate distribution**: distribution of a single variable (for example, the distribution of Age; useful summaries include mean, median, mode, variance).
- **Bivariate distribution**: joint distribution of two variables, often summarized in contingency tables or scatterplots, showing how pairs of values co‑occur and revealing association or dependence.
- **Multivariate distribution**: joint distribution of three or more variables. For k = 3 relationships can still be represented (for example via 3D views or layered tables); for k > 3 summaries rely on algebraic objects (for example covariance matrices) or multivariate models.

---

# Computing K univariant distributions

In this homework, as you can see below, i have used a population of 50 units of people. Each unit has 4 attributes: name (Nome), age (Età),
height (altezza) and weight (peso).
Only the last three attributes has been used.

The tecnologies used in this part of the homework are MySQL Workbench (Oracle) for executing queries and creating views and MS Access for the data visualization. Meanwhile all the datas are all synthetic and generated by ChatGPT.

<div align='center' markdown="1">

| ID | Nome                | Età | Altezza (cm) | Peso (kg) |
|----|----------------------|-----|---------------|-----------|
| 1  | Mario Rossi          | 32  | 178.5         | 75.2      |
| 2  | Luca Bianchi         | 25  | 182.0         | 80.1      |
| 3  | Giulia Verdi         | 29  | 165.3         | 58.4      |
| 4  | Francesca Neri       | 41  | 170.2         | 64.7      |
| 5  | Andrea Gallo         | 36  | 176.8         | 72.0      |
| 6  | Chiara Romano        | 23  | 160.4         | 54.2      |
| 7  | Davide Conti         | 28  | 185.0         | 83.6      |
| 8  | Laura Rizzi          | 35  | 168.9         | 62.5      |
| 9  | Simone Greco         | 27  | 180.6         | 77.1      |
| 10 | Elisa Moretti        | 31  | 162.7         | 56.3      |
| 11 | Federico Esposito    | 33  | 175.0         | 70.5      |
| 12 | Martina Costa        | 26  | 167.3         | 59.9      |
| 13 | Giorgio Fontana      | 45  | 179.2         | 82.0      |
| 14 | Ilaria Gatti         | 22  | 158.8         | 52.4      |
| 15 | Paolo Marchetti      | 39  | 183.4         | 85.7      |
| 16 | Sara Colombo         | 30  | 169.5         | 61.3      |
| 17 | Alessio Ferri        | 28  | 181.7         | 79.5      |
| 18 | Beatrice Marini      | 34  | 166.1         | 60.2      |
| 19 | Riccardo Leone       | 26  | 177.9         | 74.6      |
| 20 | Eleonora Bruno       | 40  | 164.8         | 59.0      |
| 21 | Stefano Fiore        | 37  | 180.0         | 78.3      |
| 22 | Valentina Greco      | 24  | 163.9         | 55.8      |
| 23 | Gabriele Serra       | 29  | 182.5         | 82.1      |
| 24 | Claudia Riva         | 32  | 170.7         | 63.2      |
| 25 | Matteo Testa         | 27  | 174.3         | 69.0      |
| 26 | Alessandra Villa     | 33  | 168.0         | 61.5      |
| 27 | Tommaso De Luca      | 38  | 185.5         | 88.9      |
| 28 | Roberta Parisi       | 36  | 165.2         | 60.0      |
| 29 | Emanuele Puglisi     | 42  | 178.8         | 84.4      |
| 30 | Veronica Longo       | 31  | 160.6         | 53.8      |
| 31 | Lorenzo Rizzi        | 25  | 179.5         | 75.6      |
| 32 | Marta Fabbri         | 29  | 162.0         | 57.1      |
| 33 | Pietro Cattaneo      | 35  | 184.1         | 86.2      |
| 34 | Silvia De Santis     | 28  | 167.4         | 59.4      |
| 35 | Davide Lombardi      | 30  | 180.3         | 80.5      |
| 36 | Camilla D’Amico      | 23  | 159.7         | 51.9      |
| 37 | Nicola Gallo         | 26  | 176.9         | 72.4      |
| 38 | Elena Ferraro        | 27  | 165.6         | 58.0      |
| 39 | Carlo Bianco         | 43  | 182.9         | 85.3      |
| 40 | Serena Palmieri      | 24  | 161.5         | 54.9      |
| 41 | Giovanni Basile      | 39  | 178.2         | 81.7      |
| 42 | Angela Caruso        | 37  | 166.9         | 62.1      |
| 43 | Fabio Grassi         | 34  | 180.8         | 77.9      |
| 44 | Lucia Vitale         | 29  | 164.2         | 58.8      |
| 45 | Daniele Riva         | 31  | 177.3         | 74.2      |
| 46 | Alice Leone          | 25  | 162.9         | 55.6      |
| 47 | Marco Ferrara        | 33  | 181.0         | 79.1      |
| 48 | Giada Pellegrini     | 30  | 168.5         | 60.7      |
| 49 | Antonio Sanna        | 41  | 183.7         | 86.5      |
| 50 | Elena Gallo          | 28  | 160.2         | 54.1      |

</div>

---

## Distribution of ages

Here, as you can see, i have used an interval of 5 years

![Age chart]({{ site.baseurl }}/assets/HMW1/ages_distribution.png)

---

## Distribution of heights

For ages i have used, instead, an interval of 5 cm.

![Height chart]({{ site.baseurl }}/assets/HMW1/heights_distribution.png)

---

## Distribution of weights

Here, the interval is of 5 kilos.

![Weight chart]({{ site.baseurl }}/assets/HMW1/weights_distribution.png)

---

# Caesar cipher

The **Caesar cipher** is a very simple substitution cipher that shifts every letter in the message by a fixed amount `k`.  
If `k = 3`, then `A → D`, `B → E`, ..., `Z → C`.  
Encryption (on letters mapped to `0..25`): `C = (P + k) mod 26`.  
Decryption: `P = (C - k) mod 26`.

**Example:** plaintext `HELLO`, key `3` → ciphertext `KHOOR`.

## Vulnerabilities (why it’s weak)
- **Tiny keyspace / trivial brute force** — there are only 25 nontrivial shifts, so an attacker can try all keys instantly.  
- **Preserves letter frequencies** — the cipher only permutes letters, so common letters (like `E` in English) remain common; frequency analysis recovers the mapping quickly.  
- **Repeated patterns stay repeated** — double letters or short repeated groups remain double/repeated in the ciphertext, leaking structure.  
- **Known-plaintext / chosen-plaintext** — if an attacker knows or can choose some plaintext, the key is recovered immediately.  
- **No integrity or authentication** — the cipher provides no protection against tampering; changes to ciphertext produce predictable changes in plaintext.

In the following paragraph we will see how easy it is to decrypt a Caesar cipher by knowing the distribution of the letters.
In fact, if we know that a letter has a very high probability to appear (for example , in the english alphabet, is the letter `E`) and we notice a letter in the encrypted text that appear with the same probability, we have probably decrypted that letter, and so, discovered the shift and decrypted the
entire text.

## Encrypting a text by using Javascript

```html
<!doctype html>
<meta charset="utf-8">
<title>Caesar Cipher — Safe Demo</title>

<textarea id="input">Hello, World!</textarea>
<input id="shift" type="number" value="3">
<button id="go">Encrypt</button>
<pre id="out"></pre>

<script>
  // JavaScript: Caesar cipher helper functions and UI hookup

  // Normalize the shift value to the range 0..25.
  // This handles negative shifts and shifts greater than 26.
  function normalizeShift(shift) {
    // The first modulus can be negative for negative shifts,
    // so add 26 and take modulus again to ensure a value in 0..25.
    return ((shift % 26) + 26) % 26;
  }

  // Return true if the Unicode code corresponds to an uppercase ASCII letter (A-Z)
  function isUppercase(code) {
    return code >= 65 && code <= 90; // 'A' = 65, 'Z' = 90
  }

  // Return true if the Unicode code corresponds to a lowercase ASCII letter (a-z)
  function isLowercase(code) {
    return code >= 97 && code <= 122; // 'a' = 97, 'z' = 122
  }

  // Apply the normalized shift to an uppercase letter.
  // - code: Unicode code of the letter (65..90)
  // - s: normalized shift (0..25)
  // Steps:
  // 1) Map 'A'..'Z' to 0..25 by subtracting 65
  // 2) Add the shift and wrap with %26
  // 3) Convert back to Unicode code by adding 65
  // 4) Return the character from the Unicode code
  function shiftUppercase(code, s) {
    const pos = code - 65;
    const shiftedPos = (pos + s) % 26;
    return String.fromCharCode(shiftedPos + 65);
  }

  // Apply the normalized shift to a lowercase letter.
  // Same logic as shiftUppercase but using 97 ('a') as base.
  function shiftLowercase(code, s) {
    const pos = code - 97;
    const shiftedPos = (pos + s) % 26;
    return String.fromCharCode(shiftedPos + 97);
  }

  // Main encryption function: iterates over each character and applies Caesar shift
  // - text: input string to encrypt
  // - shift: integer shift (can be negative or >26)
  // Returns the encrypted string.
  function caesarEncrypt(text, shift) {
    const s = normalizeShift(shift); // normalized shift in 0..25
    let result = '';                 // build the output string here

    // Loop through each character of the input text
    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const code = text.charCodeAt(i); // Unicode code of the current character

      if (isUppercase(code)) {
        // If uppercase letter, apply uppercase shifting logic
        result += shiftUppercase(code, s);
      } else if (isLowercase(code)) {
        // If lowercase letter, apply lowercase shifting logic
        result += shiftLowercase(code, s);
      } else {
        // Non-alphabetic characters (spaces, punctuation, numbers, accented chars...)
        // are left unchanged.
        result += ch;
      }
    }

    return result;
  }

  // Hook up the UI:
  // When the "Encrypt" button is clicked, read the text and shift input,
  // call caesarEncrypt and place the result in the <pre> element.
  document.getElementById('go').addEventListener('click', () => {
    const t = document.getElementById('input').value;
    // parseInt returns NaN if the value isn't a number; using "|| 0" falls back to 0.
    const s = parseInt(document.getElementById('shift').value, 10) || 0;
    document.getElementById('out').textContent = caesarEncrypt(t, s);
  });
</script>
```


**Plain text:** Sunlight spilled onto the café table as she sipped her coffee. Outside, the street hummed with morning errands and a distant bicycle bell. A stray cat found a warm patch of pavement and settled down, indifferent to the hurry around it. She wrote a single sentence in her notebook and smiled, keeping the moment.

She stayed a little longer, watching people pass—an office worker balancing a stack of papers, two students sharing earbuds and laughing, a delivery rider weaving through traffic. Steam curled from her cup and mixed with the cool air; the menu board behind the barista listed the day's specials in looping chalk. When the cat stretched and leapt up onto a windowsill, a child stopped to press a small, curious palm to the glass, and the child’s mother bent down to straighten a crooked shoelace.

By the time she left, the city felt stitched together by tiny interactions: a barista calling an order with theatrical cheer, an old dog greeting a familiar neighbor, the brief exchange of an umbrella lent during a sudden sprinkle. She tucked the notebook into her bag, pleased to have captured a few ordinary fragments she could return to later.


**Encrypted text:** Yatromnz yvorrkj utzu znk iglé zghrk gy ynk yovvkj nkx iullkk. Uazyojk, znk yzxkkz nasskj cozn suxtotm kxxgtjy gtj g joyzgtz hoieirk hkrr. G yzxge igz luatj g cgxs vgzin ul vgbksktz gtj ykzzrkj juct, otjollkxktz zu znk naxxe gxuatj oz. Ynk cxuzk g yotmrk yktzktik ot nkx tuzkhuuq gtj ysorkj, qkkvotm znk susktz.

Ynk yzgekj g rozzrk rutmkx, cgzinotm vkuvrk vgyy—gt ulloik cuxqkx hgrgtiotm g yzgiq ul vgvkxy, zcu yzajktzy yngxotm kgxhajy gtj rgamnotm, g jkrobkxe xojkx ckgbotm znxuamn zxglloi. Yzkgs iaxrkj lxus nkx iav gtj sodkj cozn znk iuur gox; znk skta hugxj hknotj znk hgxoyzg royzkj znk jge'y yvkiogry ot ruuvotm ingrq. Cnkt znk igz yzxkzinkj gtj rkgvz av utzu g cotjucyorr, g inorj yzuvvkj zu vxkyy g ysgrr, iaxouay vgrs zu znk mrgyy, gtj znk inorj’y suznkx hktz juct zu yzxgomnzkt g ixuuqkj ynukrgik.

He znk zosk ynk rklz, znk ioze lkrz yzozinkj zumkznkx he zote otzkxgizouty: g hgxoyzg igrrotm gt uxjkx cozn znkgzxoigr inkkx, gt urj jum mxkkzotm g lgsorogx tkomnhux, znk hxokl kdingtmk ul gt ashxkrrg rktz jaxotm g yajjkt yvxotqrk. Ynk zaiqkj znk tuzkhuuq otzu nkx hgm, vrkgykj zu ngbk igvzaxkj g lkc uxjotgxe lxgmsktzy ynk iuarj xkzaxt zu rgzkx.

## Calculating the distributions of letters

```html
<!doctype html>
<html>
<body>

<textarea id="input" rows="10" cols="60">Paste your text here...</textarea>
<br>
<button id="analyze">Analyze</button>

<pre id="output"></pre>

<script>
  // Compute letter frequencies for ASCII A-Z (case-insensitive)
  function computeFrequencies(text) {
    const counts = {};
    // initialize A..Z counts to zero
    for (let i = 65; i <= 90; i++) counts[String.fromCharCode(i)] = 0;
    let total = 0;

    // fold to uppercase to be case-insensitive
    const src = text.toUpperCase();
    for (let i = 0; i < src.length; i++) {
      const c = src[i];
      if (c >= 'A' && c <= 'Z') {
        counts[c] = counts[c] + 1;
        total++;
      }
    }
    return { counts, total };
  }

  // Render results into the <pre> element on the page
  function renderResults(counts, total, outEl) {
    const lines = [];
    lines.push('Letter  Count  Percentage');
    for (let i = 65; i <= 90; i++) {
      const letter = String.fromCharCode(i);
      const count = counts[letter] || 0;
      const pct = total === 0 ? 0 : (count / total) * 100;
      // simple aligned formatting
      const padLetter = letter;
      const padCount = String(count).padStart(5, ' ');
      const padPct = pct.toFixed(2).padStart(8, ' ');
      lines.push(padLetter + '      ' + padCount + '   ' + padPct + '%');
    }
    lines.push('');
    lines.push('Total letters counted: ' + total);
    outEl.textContent = lines.join('\n');
  }

  // Hook up UI
  document.getElementById('analyze').addEventListener('click', function () {
    const text = document.getElementById('input').value || '';
    const { counts, total } = computeFrequencies(text);
    const outEl = document.getElementById('output');
    renderResults(counts, total, outEl);
  });
</script>

</body>
</html>
```

### Distribution of letters of the plain text
| Letter | Count | Percentage |
|--------|-------:|-----------:|
| A      |     81 | 8.71% |
| B      |     18 | 1.94% |
| C      |     34 | 3.66% |
| D      |     49 | 5.27% |
| E      |    117 | 12.58% |
| F      |     20 | 2.15% |
| G      |     25 | 2.69% |
| H      |     53 | 5.70% |
| I      |     59 | 6.34% |
| J      |      0 | 0.00% |
| K      |      9 | 0.97% |
| L      |     47 | 5.05% |
| M      |     19 | 2.04% |
| N      |     64 | 6.88% |
| O      |     56 | 6.02% |
| P      |     23 | 2.47% |
| Q      |      0 | 0.00% |
| R      |     58 | 6.24% |
| S      |     53 | 5.70% |
| T      |     90 | 9.68% |
| U      |     23 | 2.47% |
| V      |      4 | 0.43% |
| W      |     15 | 1.61% |
| X      |      2 | 0.22% |
| Y      |     11 | 1.18% |
| Z      |      0 | 0.00% |

### Distribution of letters of the encrypted text
| Letter | Count | Percentage |
|--------|------:|-----------:|
| A      |    23 | 2.47% |
| B      |     4 | 0.43% |
| C      |    15 | 1.61% |
| D      |     2 | 0.22% |
| E      |    11 | 1.18% |
| F      |     0 | 0.00% |
| G      |    81 | 8.71% |
| H      |    18 | 1.94% |
| I      |    34 | 3.66% |
| J      |    49 | 5.27% |
| K      |   117 | 12.58% |
| L      |    20 | 2.15% |
| M      |    25 | 2.69% |
| N      |    53 | 5.70% |
| O      |    59 | 6.34% |
| P      |     0 | 0.00% |
| Q      |     9 | 0.97% |
| R      |    47 | 5.05% |
| S      |    19 | 2.04% |
| T      |    64 | 6.88% |
| U      |    56 | 6.02% |
| V      |    23 | 2.47% |
| W      |     0 | 0.00% |
| X      |    58 | 6.24% |
| Y      |    53 | 5.70% |
| Z      |    90 | 9.68% |


### Conclsions
Seeing the distributions of letters both of the plain text and the encrypted text we have discovered all the encrypted letters.
By confronting the distributions of letters of the palin text and the encrypted text, we can assume that, seeing that the letter `E` (from the plain text) corresponds to the letter `K` (encrypted text), the ceasar text had a shift of 6.