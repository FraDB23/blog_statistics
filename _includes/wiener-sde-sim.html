<div id="wiener-sde-sim">

  <style>
    /* ===========================
       BASIC LAYOUT (GRAPH + TEXT)
       =========================== */

    #wss-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 14px;
    }

    #wss-controls label {
      font-size: 13px;
    }

    #wss-controls input[type="number"] {
      width: 80px;
    }

    #wss-controls input[type="text"] {
      width: 220px;
    }

    /* Canvas for sample paths */
    #wss-canvas {
      display: block;
      border: 1px solid #ccc;
      background: #fff;
      margin-bottom: 12px;
      max-width: 100%;
    }

    /* Output text area */
    #wss-summary {
      font-family: monospace;
      white-space: pre-wrap;   /* preserves line breaks from JS */
      word-wrap: break-word;
      width: 100%;
      box-sizing: border-box;
      padding: 10px;
      border: 1px solid #ddd;
      background: #fafafa;
    }

    .small {
      font-size: 12px;
      color: #555;
    }

    button {
      padding: 6px 10px;
      cursor: pointer;
    }
  </style>

  <!-- ===========================
       USER INPUT CONTROLS
       =========================== -->

  <div id="wss-controls">
    <label>T: <input id="wss-T" type="number" step="0.1" value="1"></label>
    <label>n: <input id="wss-n" type="number" value="1000"></label>
    <label># paths: <input id="wss-m" type="number" value="10"></label>
    <label>X₀: <input id="wss-x0" type="number" value="0"></label>

    <label>mu(x,t): <input id="wss-mu" type="text" value="0"></label>
    <label>sigma(x,t): <input id="wss-sigma" type="text" value="1"></label>

    <button id="wss-run">Simulate</button>

    <div class="small">
      Example (Geometric Brownian Motion): mu = 0.1*x , sigma = 0.3*x
    </div>
  </div>

  <!-- ===========================
       GRAPH AREA
       =========================== -->
  <canvas id="wss-canvas" width="820" height="360"></canvas>

  <!-- ===========================
       TEXT OUTPUT AREA
       =========================== -->
  <div id="wss-summary">No simulation yet.</div>

  <script>
    /* ============================================================
       1) STANDARD NORMAL RANDOM VARIABLE  ~ N(0,1)
       ------------------------------------------------------------
       Brownian motion increments satisfy:
           ΔW ~ Normal(0, Δt)

       We generate a Normal(0,1) using the Box–Muller transform:
           Z = sqrt(-2 ln U) cos(2πV)
       with U, V ~ Uniform(0,1).
       ============================================================ */
    function normal() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    /* ============================================================
       2) BASIC STATISTICS: SAMPLE MEAN AND SAMPLE VARIANCE
       ------------------------------------------------------------
       Mean:
           \bar{X} = (1/n) Σ X_i

       Variance (unbiased estimator):
           S² = (1/(n-1)) Σ (X_i - \bar{X})²
       ============================================================ */
    function mean(arr) {
      return arr.reduce((a, b) => a + b, 0) / arr.length;
    }

    function variance(arr) {
      const m = mean(arr);
      return arr.reduce((s, x) => s + (x - m) ** 2, 0) / (arr.length - 1);
    }

    /* ============================================================
       3) EULER–MARUYAMA METHOD FOR STOCHASTIC DIFFERENTIAL EQUATIONS
       ------------------------------------------------------------
       Generic SDE:

           dX_t = μ(X_t, t) dt + σ(X_t, t) dW_t

       The Euler–Maruyama discretization over a small time step dt is:

           X_{k+1} = X_k + μ(X_k, t_k) dt + σ(X_k, t_k) ΔW_k

       where:
           ΔW_k ~ Normal(0, dt) = sqrt(dt) * Normal(0,1)

       This converges with strong order 1/2 for general SDEs.
       ============================================================ */
    function eulerMaruyama(mu, sigma, X0, T, n, M) {

      // Time step length
      const dt = T / n;

      // Discrete time grid: t_0 = 0, t_n = T
      const t = Array.from({ length: n + 1 }, (_, i) => i * dt);

      // Store M independent sample paths
      const paths = [];

      for (let i = 0; i < M; i++) {
        const X = [X0];   // initial condition X(0) = X0

        for (let j = 0; j < n; j++) {

          // Brownian increment ΔW ~ N(0, dt)
          const dW = Math.sqrt(dt) * normal();

          // Euler–Maruyama update
          X.push(
            X[j]
            + mu(X[j], t[j]) * dt
            + sigma(X[j], t[j]) * dW
          );
        }

        paths.push(X);
      }

      return { t, paths, dt };
    }

    /* ============================================================
       4) CANVAS SETUP FOR GRAPHICAL DISPLAY
       ============================================================ */
    const canvas = document.getElementById("wss-canvas");
    const ctx = canvas.getContext("2d");

    /* ============================================================
       5) PLOTTING FUNCTION FOR SAMPLE PATHS
       ------------------------------------------------------------
       Each sample path is a realization of the stochastic process
       on the interval [0, T].

       For Brownian motion:
           - paths are continuous
           - nowhere differentiable
           - variance grows linearly in time
       ============================================================ */
    function plot(sim) {

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const { t, paths } = sim;

      // Determine vertical plotting range from data
      let ymin = Infinity, ymax = -Infinity;
      paths.forEach(p => p.forEach(v => {
        ymin = Math.min(ymin, v);
        ymax = Math.max(ymax, v);
      }));

      const pad = 40;

      function mapX(x) {
        return pad + (x / t[t.length - 1]) * (canvas.width - 2 * pad);
      }

      function mapY(y) {
        return canvas.height - pad -
          ((y - ymin) / (ymax - ymin)) * (canvas.height - 2 * pad);
      }

      // Draw each sample path with different color
      paths.forEach((path, i) => {
        ctx.beginPath();
        ctx.strokeStyle = `hsla(${i * 360 / paths.length},80%,40%,0.6)`;
        path.forEach((v, j) => {
          const x = mapX(t[j]);
          const y = mapY(v);
          if (j === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      });
    }

    /* ============================================================
       6) MAIN BUTTON: RUN SIMULATION
       ============================================================ */
    document.getElementById("wss-run").onclick = () => {

      const T = +wss_T.value;     // total time horizon
      const n = +wss_n.value;     // number of time steps
      const M = +wss_m.value;     // number of paths
      const X0 = +wss_x0.value;  // initial value

      // Convert user input into actual functions
      const mu = new Function("x", "t", "return " + wss_mu.value);
      const sigma = new Function("x", "t", "return " + wss_sigma.value);

      // Run Euler–Maruyama
      const sim = eulerMaruyama(mu, sigma, X0, T, n, M);

      // Plot sample paths
      plot(sim);

      // Collect final values X_T for all paths
      const XT = sim.paths.map(p => p[p.length - 1]);

      /* ========================================================
         FOR WIENER PROCESS (μ = 0, σ = 1):

         THEORY:
           E[X_T] = 0
           Var(X_T) = T

         These values should be matched approximately
         by the empirical estimates below.
         ======================================================== */

      wss_summary.textContent = 
`Euler–Maruyama SDE Simulation

SDE:
  dX_t = mu(X_t,t) dt + sigma(X_t,t) dW_t

Drift  mu(x,t)    = ${wss_mu.value}
Diffus sigma(x,t)= ${wss_sigma.value}

Time horizon T = ${T}
Number of steps n = ${n}
Time step dt = ${(T/n).toFixed(6)}

Number of simulated paths = ${M}

EMPIRICAL FINAL-TIME STATISTICS:

Sample mean of X_T     = ${mean(XT).toFixed(6)}
Sample variance of X_T = ${variance(XT).toFixed(6)}

BROWNIAN MOTION SETUP:
  mu = 0
  sigma = 1

THEORETICAL VALUES FOR WIENER PROCESS:
  E[X_T] = 0
  Var(X_T) = T`;
    };
  </script>
</div>

