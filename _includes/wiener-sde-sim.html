<div id="wiener-sde-sim">

  <style>
    #wss-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 14px;
    }

    #wss-controls label { font-size: 13px; }
    #wss-controls input[type="number"] { width: 80px; }
    #wss-controls input[type="text"] { width: 220px; }

    #wss-canvas {
      display: block;
      border: 1px solid #ccc;
      background: #fff;
      margin-bottom: 12px;
      max-width: 100%;
    }

    #wss-summary {
      font-family: monospace;
      white-space: pre-wrap;
      word-wrap: break-word;
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      background: #fafafa;
    }

    .small { font-size: 12px; color: #555; }
    button { padding: 6px 10px; cursor: pointer; }
  </style>

  <div id="wss-controls">
    <label>T: <input id="wss-T" type="number" step="0.1" value="1"></label>
    <label>n: <input id="wss-n" type="number" value="1000"></label>
    <label># paths: <input id="wss-m" type="number" value="10"></label>
    <label>X₀: <input id="wss-x0" type="number" value="0"></label>

    <label>mu(x,t): <input id="wss-mu" type="text" value="0"></label>
    <label>sigma(x,t): <input id="wss-sigma" type="text" value="1"></label>

    <button id="wss-run">Simulate</button>

    <div class="small">Brownian motion: mu = 0 , sigma = 1</div>
  </div>

  <canvas id="wss-canvas" width="820" height="360"></canvas>
  <div id="wss-summary">No simulation yet.</div>

  <script>
    /* ===========================
       STANDARD NORMAL N(0,1)
       =========================== */
    function normal() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    /* ===========================
       SAMPLE MEAN AND VARIANCE
       =========================== */
    function mean(arr) {
      return arr.reduce((a, b) => a + b, 0) / arr.length;
    }

    function variance(arr) {
      if (arr.length < 2) return 0;
      const m = mean(arr);
      return arr.reduce((s, x) => s + (x - m) ** 2, 0) / (arr.length - 1);
    }

    /* ===========================
       EULER–MARUYAMA METHOD
       =========================== */
    function eulerMaruyama(mu, sigma, X0, T, n, M) {
      const dt = T / n;
      const t = Array.from({ length: n + 1 }, (_, i) => i * dt);
      const paths = [];

      for (let i = 0; i < M; i++) {
        const X = [X0];

        for (let j = 0; j < n; j++) {
          const dW = Math.sqrt(dt) * normal();
          X.push(
            X[j] +
            mu(X[j], t[j]) * dt +
            sigma(X[j], t[j]) * dW
          );
        }

        paths.push(X);
      }

      return { t, paths, dt };
    }

    /* ===========================
       CANVAS PLOTTING
       =========================== */
    const canvas = document.getElementById("wss-canvas");
    const ctx = canvas.getContext("2d");

    function plot(sim) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const { t, paths } = sim;

      let ymin = Infinity, ymax = -Infinity;
      paths.forEach(p => p.forEach(v => {
        ymin = Math.min(ymin, v);
        ymax = Math.max(ymax, v);
      }));

      const pad = 40;
      function mapX(x) {
        return pad + (x / t[t.length - 1]) * (canvas.width - 2 * pad);
      }
      function mapY(y) {
        return canvas.height - pad -
          ((y - ymin) / (ymax - ymin)) * (canvas.height - 2 * pad);
      }

      paths.forEach((path, i) => {
        ctx.beginPath();
        ctx.strokeStyle = `hsla(${i * 360 / paths.length},80%,40%,0.6)`;
        path.forEach((v, j) => {
          const x = mapX(t[j]);
          const y = mapY(v);
          if (j === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      });
    }

    /* ===========================
         MAIN SIMULATE BUTTON
       =========================== */
    document.getElementById("wss-run").addEventListener("click", function () {

      const T = Number(document.getElementById("wss-T").value);
      const n = Number(document.getElementById("wss-n").value);
      const M = Number(document.getElementById("wss-m").value);
      const X0 = Number(document.getElementById("wss-x0").value);

      const muText = document.getElementById("wss-mu").value;
      const sigmaText = document.getElementById("wss-sigma").value;

      const mu = new Function("x", "t", "return " + muText);
      const sigma = new Function("x", "t", "return " + sigmaText);

      const sim = eulerMaruyama(mu, sigma, X0, T, n, M);
      plot(sim);

      const XT = sim.paths.map(p => p[p.length - 1]);

      document.getElementById("wss-summary").textContent =
`Euler–Maruyama SDE Simulation

dX = mu(X,t) dt + sigma(X,t) dW

mu(x,t)    = ${muText}
sigma(x,t) = ${sigmaText}

T = ${T}
n = ${n}
dt = ${(T/n).toFixed(6)}

paths = ${M}

Sample mean of X_T     = ${mean(XT).toFixed(6)}
Sample variance of X_T = ${variance(XT).toFixed(6)}

For Wiener process:
mu = 0
sigma = 1

Theoretical values:
E[X_T] = 0
Var(X_T) = T`;
    });
  </script>
</div>

